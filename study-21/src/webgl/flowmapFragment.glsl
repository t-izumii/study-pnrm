precision highp float;

// ========================================
// ユニフォーム変数（CPU側から受け取る値）
// ========================================
uniform sampler2D uPreviousFlow;  // 前フレームのフローマップテクスチャ
uniform vec2 uMouse;               // マウス位置（0.0〜1.0の正規化座標）
uniform vec2 uVelocity;            // マウスの速度（前フレームとの差分）
uniform float uDecay;              // 減衰率（0.96 = 毎フレーム4%ずつ弱まる）
uniform float uInfluenceRadius;    // マウスの影響範囲（0.15 = 画面の15%）
uniform float uStrength;           // 流れの強さ（大きいほど強い歪み）

// ========================================
// バリイング変数（頂点シェーダーから補間された値）
// ========================================
varying vec2 vUv;  // 現在処理中のピクセルのUV座標（0.0〜1.0）

void main() {
    // ========================================
    // STEP 1: 前フレームの流れを取得
    // ========================================
    // このピクセル位置における前フレームの流れの値を読み込む
    // .rg = 赤と緑のチャンネル = X方向とY方向の流れの強さ
    vec2 flow = texture2D(uPreviousFlow, vUv).rg;
    
    // ========================================
    // STEP 2: マウスからの距離を計算
    // ========================================
    // 現在のピクセル位置からマウス位置までのベクトル
    vec2 diff = vUv - uMouse;
    // 例: vUv=(0.5, 0.5), uMouse=(0.3, 0.4) の場合
    //     diff = (0.2, 0.1) → マウスから右上に0.2, 0.1離れている
    
    // ユークリッド距離（直線距離）を計算
    float dist = length(diff);
    // 例: dist = sqrt(0.2^2 + 0.1^2) = sqrt(0.05) ≈ 0.224
    
    // ========================================
    // STEP 3: マウスの影響度を計算
    // ========================================
    // smoothstep関数で滑らかな減衰を作る
    // smoothstep(edge0, edge1, x):
    //   - x >= edge0 の場合: 0を返す
    //   - x <= edge1 の場合: 1を返す
    //   - edge0 < x < edge1: 滑らかに補間された値（S字カーブ）
    float influence = smoothstep(uInfluenceRadius, 0.0, dist);
    
    // 具体例（uInfluenceRadius = 0.15の場合）:
    //   dist = 0.0（マウス直下）  → influence = 1.0（最大影響）
    //   dist = 0.075（中間地点）  → influence ≈ 0.5（半分の影響）
    //   dist = 0.15（影響範囲端） → influence = 0.0（影響なし）
    //   dist = 0.2（範囲外）      → influence = 0.0（影響なし）
    
    // ========================================
    // STEP 4: 新しい流れを追加
    // ========================================
    // マウスの移動速度に基づいて、新しい流れを生成
    // Y軸の符号を反転して座標系を統一
    vec2 adjustedVelocity = vec2(uVelocity.x, -uVelocity.y);
    // 計算式: 速度 × 影響度 × 強度係数
    flow += adjustedVelocity * influence * uStrength;
    
    // 例: マウスが右に速く動いている場合
    //     uVelocity = (0.02, 0.0)  // X方向に正の値
    //     influence = 0.8           // マウスに近い
    //     uStrength = 1.5          // 強度設定
    //     追加される流れ = (0.02 * 0.8 * 1.5, 0) = (0.024, 0)
    //     → このピクセルに右向きの流れが追加される
    
    // ========================================
    // STEP 5: 時間経過による減衰を適用
    // ========================================
    // 流れを徐々に弱める（粘性のある液体のような効果）
    flow *= uDecay;
    
    // 例: uDecay = 0.96 の場合
    //     flow = (0.1, 0.05) → (0.096, 0.048)
    //     毎フレーム4%ずつ弱まっていく
    //     約17フレーム後には半分の強さに
    //     約70フレーム後にはほぼゼロに
    
    // ========================================
    // STEP 6: 最終的なフローマップとして出力
    // ========================================
    // 色として出力（次のフレームで uPreviousFlow として読まれる）
    // R channel: X方向の流れ（-1.0 = 左, 0.0 = 静止, +1.0 = 右）
    // G channel: Y方向の流れ（-1.0 = 下, 0.0 = 静止, +1.0 = 上）
    // B channel: 未使用（将来の拡張用、現在は0.0）
    // A channel: アルファ値（常に1.0で不透明）
    gl_FragColor = vec4(flow, 0.0, 1.0);
    
    // デバッグ用：フローマップを可視化したい場合
    // gl_FragColor = vec4(flow * 0.5 + 0.5, 0.0, 1.0);  // -1〜1を0〜1に変換して表示
}